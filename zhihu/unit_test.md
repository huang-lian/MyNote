# 单元测试

## [gashero](https://www.zhihu.com/people/gashero) 为单元测试划分的5个级别
作者：gashero  
链接：https://www.zhihu.com/question/27313846/answer/120164282  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处.

> 1. Level1：正常流程可用，即一个函数在输入正确的参数时，会有正确的输出  
> 2. Level2：异常流程可抛出逻辑异常，即输入参数有误时，不能抛出系统异常，而是用自己定义的逻辑异常通知上层调用代码其错误之处  
> 3. Level3：极端情况和边界数据可用，对输入参数的边界情况也要单独测试，确保输出是正确有效的  
> 4. Level4：所有分支、循环的逻辑走通，不能有任何流程是测试不到的5. Level5：输出数据的所有字段验证，对有复杂数据结构的输出，确保每个字段都是正确的  
>
> 如上的单元测试分级是我2007年整理出来的，后来在我做的各种项目中，一般只做到Level2，重要系统或者底层服务，要做到Level3或Level4。而很少做到Level5。即便如此，就已经实现了如上所说的，很难被测试工程师发现bug。


## [gashero](https://www.zhihu.com/people/gashero)谈单元测试构造数据
作者：gashero  
链接：https://www.zhihu.com/question/27313846/answer/120164282  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

> 单元测试一大痛苦是构造测试数据。
>
> 我的看法是测试数据应该是人造的，而不是随便从产品环境 dump 出来一份。只有人造的数据能确保环境可控，每次运行不会因为环境改变而频繁修改 testcase 。
>
> 我的常用玩法是测试数据分为基础数据和附加数据两部分。  
> - 基础数据是所有 testcase 共享的，比如建立几个常用角色的用户等等。  
> - 附加数据是 testcase 内部自己建立的。  
> 这样每次 testcase 运行时，先清空数据库，导入基础数据，导入附加数据，然后执行测试，验证结果。  
>
> 各类程序的函数可以分为纯函数和副作用函数。  
> - 纯函数对应的是数学里函数的概念，输出和输入是一一对应的。对一个输入有确定的输出。比如`1+1=2`。  
> - 而副作用函数则相反，同样的输入，在不同时间和环境里，可能有不同的输出。比如任何涉及 IO 、网络、数据库的。  
>
> 副作用函数的测试比纯函数麻烦的多，因为你必须要完整的构造其所依赖的所有环境，才能够复现一个副作用函数的行为。也正因为如此，副作用函数出 bug 的概率比纯函数高的多。  
> 理解这个概念以后，应该尽可能的把程序里的纯函数和副作用函数进行拆解，降低副作用函数的比例和逻辑复杂度。还有，副作用函数是会传染的，一个函数如果调用了副作用函数，那么它也会变成副作用函数。  

## [陈萌萌](https://www.zhihu.com/people/jjmoe)说单元测试的一些原则
作者：陈萌萌  
链接：https://www.zhihu.com/question/27313846/answer/130954707  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

> 写单元测试的一些原则：  
> 1）测试用例能验证函数的正确性（这条都通不过就……）；  
> 2）测试用例尽可能涵盖边界条件（例如遍历一个链表，头指针是空，只有一个节点，链表有N个节点，N是问题描述下允许的最大节点数等等）；  
> 3）一些异常和错误处理（例如往一个函数里传入空指针，传入空串，这个函数能否打印一些log，返回错误码，实现加法的Add函数如何检测和处理溢出等等)
>
> 最理想的情况下（时间很多！），应该尽量多写测试用例，以保证代码功能的正确性符合预期，具有良好的容错性。如果代码较复杂，条件分支较多，测试用例最好能覆盖所有的分支路径。上述原则一般解决了很多“应该测试什么”的问题。
> 推荐： Google 的测试框架。 gtest （ Google Test ）和 gmock （ Google Mock  ）。

## [minrong](https://www.zhihu.com/people/minrong-xu-54) 理解的单元测试
作者：minrong xu  
链接：https://www.zhihu.com/question/27313846/answer/217295000  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

> - 单元测试如同 IDE 一样都是帮助我们开发的工具  
>
> - 单元测试的最好是在第一个接口完成时开始  
> 	- 否则代码多了就愿意写了  
> 	- 单元测试在写代码前期最大，而不是对后期的重构。可以说开发阶段就完成了大部分的重构工作。  
> 		- 每个单元的测试函数应该尽量少，迫使你关注接口设计：好的接口要功能明确，职责单一，合理分层。  
> 		- 单元测试需要避免过度依赖mock，则迫使你尽量让代码独立，降低耦合，减少对其他模块或者环境的依赖。  
> 		- 单元测试还助于帮助写出符合开放封闭原则的代码。  
>
> - 写单元测试对整体时间来说是缩短了，而不是延长了。  
> 	- 真正写单元测试代码，单元测试代码应该很少，否则说明接口设计有问题。  
> 	- 单元测试可以自动化一个功能的：询试、编译、发布，手动验证、环境配置等部分  
> 	- 单元测试代码提前协助做了重构。  
>
> - 单元测试不应该讲代码覆盖率，而应该是功能或逻辑覆盖。  
> 	- 很多人说单元测试是白盒测试，讲求代码覆盖率。这也是很多人觉得单元测试代码难写的原因之一  
> 	- 某一个接口函数，是干什么的，有几种可能性，都考虑到了，写了相关的测试函数，也就可以了。虽然说不讲代码覆盖率，不过这些覆盖了，代码也就覆盖了，否则可能有废代码。  
> 	- 还有，从接口函数角度看，我觉得单元测试是黑盒的。而且允许里面的实现变动，只要测试函数都能通过即可。  
>
> - 单元测试仅仅是个辅助的开发工具，不是非它不可。有框架可以用框架，没框架自已写个简单的程序验证一下自已的假设即可。我的建议是早点动手实践，在实践中反思。没有真正想通，或觉得没用，就先放一放。  

## [L晓霓](https://www.zhihu.com/people/lxiao-ni) 的两个单元测试小窍门
作者：L晓霓  
链接：https://www.zhihu.com/question/27313846/answer/120420611  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处.  
> 1. 尽量不要干涉原来的代码。从阅读代码的体验来说，不要让你的测试（哪怕是一小段 if..else...的代码）出现在你准备测试的代码中。  
> 2. 代码要只是测试某个class里面的一个特定的 function。这个 function 不能太简单，太简单就没有测试的意义；也不能太复杂，不应该牵涉太多其他的 class ，如果太复杂就不应该写 unit test，而考虑其他的测试方法。

## 测试驱动开发（TDD：Test-Driven Development)
<https://zh.wikipedia.org/zh-hans/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91>
> 其倡导先写测试程序，然后编码实现其功能
>
> 测试驱动开发是戴两顶帽子思考的开发方式：
> 1. 先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；
> 2. 再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。
>
> 测试驱动着整个开发过程：
> 1. 首先，驱动代码的设计和功能的实现；
> 2. 其后，驱动代码的再设计和重构。

## 王垠谈 [测试的道理](http://www.yinwang.org/blog-cn/2016/09/14/tests)
> - 必须有实战的技巧,而不是夸夸其谈，测试并非唯一提高代码质量的方法
> - 不要被测试捆住手脚，更快的达到终点才是目的
> 	- 写测试不是必须的。并非每个bug都要写测试的。
> 	- 要有自己的思考，而不是人云亦云的依从教条
> - 测试的重点在于程序需要满足的功能而该是算法的实现细节
> - 避免使用mock，特别是多层mock
> - 一个测试只测一方面。simple is best.
> - 避免字符串比较的测试（printf）

## [maxSonic](https://www.zhihu.com/people/maxsonic)理解的自动化测试
作者：maxSonic  
链接：https://www.zhihu.com/question/19721142/answer/13458098  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  
> - 测试最重要的是对系统以及需求的理解,然后才能设计出实用的测试用例。
> - 自动化测试的目的是更多减少测试时间，把更多的时间用于理解需求和系统,设计测试用例.

